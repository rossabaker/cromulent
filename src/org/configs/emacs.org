#+TITLE: Emacs config
#+CREATED: <2023-02-23 Thu 23:59>
#+LAST_MODIFIED: [2023-06-19 Mon 23:57 EDT]
#+PROPERRY: header-args :tangle-mode `,#o444 :mkdirp yes
#+PROPERTY: header-args:emacs-lisp :tangle ../../../gen/emacs/init.el :tangle-mode `,#o444
#+OPTIONS: H:6

* Introduction
:PROPERTIES:
:CUSTOM_ID: introduction
:END:

** The flavor of the day is vanilla
:PROPERTIES:
:CUSTOM_ID: the-flavor-of-the-day-is-vanilla
:END:


This is a "vanilla" configuration, or an "Emacs from scratch," built
on a prerelease of Emacs 29 from Git.

Some users use a community configuration such as [[https://www.spacemacs.org/][Spacemacs]] or [[https://github.com/doomemacs/doomemacs][Doom]].  A
more moderate approach is a starter kit like like [[https://github.com/bbatsov/prelude][Prelude]] or [[https://github.com/SystemCrafters/crafted-emacs][Crafted
Emacs]], which hew closer to vanilla Emacs but give users a sensible
head start.  These are recommended paths for new users, and remain
reasonable even after decades of experience.

I choose to start from the wretched defaults.

- It helps me better understand how it works.
- I am less likely to be surprised on upgrades.
- It's relaxing.  Editor bonsai, if you will.

** Guiding principles
:PROPERTIES:
:CUSTOM_ID: guiding-principles
:END:

The default is to try built-in packages first, but be unafraid to
augment with [[https://elpa.gnu.org/][ELPA]], [[https://melpa.org/][MELPA]], or even Git.  These extra moving parts are
managed by rigorously pinning all dependencies with Nix.

* Early tasks
:PROPERTIES:
:CUSTOM_ID: early-tasks
:END:

An Emacs configuration can mostly be declared in any order,
particularly with intelligent use of ~use-package~'s ~:after~ keyword.
But there are a few things that benefit from going first.

** Startup time
:PROPERTIES:
:CUSTOM_ID: startup-time
:END:

I don't go to [[https://github.com/doomemacs/doomemacs/blob/35865ef5e89442e3809b8095199977053dd4210f/docs/faq.org#how-does-doom-start-up-so-quickly][Doom's extreme lengths]] to optimize startup time, but
there are usually a few heavy hitters, and [[https://github.com/dholm/benchmark-init-el][benchmark-init-el]] helps
find them.  And with my Nix setup, I'm restarting Emacs a lot whenever
I'm trying new packages, so it's worth a modest effort.

*** Benchmark
:PROPERTIES:
:CUSTOM_ID: benchmark
:END:

[[https://github.com/dholm/benchmark-init-el][benchmark-init]] is a simple package that may or may not carry its
weight versus ~usepackage-compute-statistics~.  Run
~benchmark-init/show-durations-tabulated~ to check this one out.

#+begin_src emacs-lisp
  (use-package benchmark-init
    :ensure t
    :demand t
    :hook (after-init . benchmark-init/deactivate)
    :config
    (benchmark-init/activate))
#+end_src

#+RESULTS:
| org-persist-load-all | benchmark-init/deactivate | tramp-register-archive-autoload-file-name-handler | magit-maybe-define-global-key-bindings | table--make-cell-map |

*** Garbage collection
:PROPERTIES:
:CUSTOM_ID: garbage-collection
:END:

Increasing the garbage collector threshold is reputed to help at init.
After startup, we revert on the [[https://gitlab.com/koral/gcmh][Garbage Collector Magic Hack]].

#+begin_src emacs-lisp
  (use-package gcmh
    :ensure t
    :diminish
    :init (setq gc-cons-threshold (* 80 1024 1024))
    :hook (emacs-startup . gcmh-mode))
#+end_src

#+RESULTS:
| gcmh-mode |

*** Doom-like hooks
:PROPERTIES:
:CUSTOM_ID: doom-like-hooks
:END:

We're also going to use [[https://gitlab.com/ajgrf/on.el][on.el]] to provide some of the same hooks Doom
uses.

#+begin_src emacs-lisp
  (use-package on
    :ensure)
#+end_src

*** Security
:PROPERTIES:
:CUSTOM_ID: security
:END:

For the love of all that is holy, do not continue with untrusted
connections!

#+begin_src emacs-lisp
  (use-package gnutls
    :defer t
    :custom
    (gnutls-verify-error t))
#+end_src

*** No littering
:PROPERTIES:
:CUSTOM_ID: no-littering
:END:

Many packages leave crumbs in ~user-emacs-directory~ or even ~$HOME~.
Finding and configuring them individually is a hassle, so we rely on
the community configuration of [[https://github.com/emacscollective/no-littering][~no-littering~]].  Run this early,
because many of the crumb droppers are configured below!

The default is to put everything under ~user-emacs-directory~, which
for me is under ~~/.config~.  If I considered any of this data to be
config, they'd be in this file!  I keep mine in ~~/.cache~.

Cleaning up the [[https://github.com/emacscollective/no-littering#native-compilation-cache][native compilation cache]] is "preferably" supposed to
happen in ~early-init.el~, but I'm trying to keep that as light as
possible so as much as possible works without Home Manager.  This
seems early enough to avoid crapping in =~/.config/emacs=.

#+begin_src emacs-lisp
  (use-package no-littering
    :ensure t
    :init
    (setq no-littering-etc-directory "~/.cache/emacs/etc/"
          no-littering-var-directory "~/.cache/emacs/var/")
    (when (fboundp 'startup-redirect-eln-cache)
      (startup-redirect-eln-cache
       (convert-standard-filename
        (expand-file-name  "eln-cache/" no-littering-var-directory)))))
#+end_src

** use-package keywords
:PROPERTIES:
:CUSTOM_ID: use-package-keywords
:END:

*** bind-key
:PROPERTIES:
:CUSTOM_ID: bind-key
:END:

[[https://github.com/jwiegley/use-package][use-package]] is built-in as of Emacs 29, but since we use =:bind=, we
need to load ~bind-key~.  If we forget, we get the error: ~Symbol's
value as variable is void: personal-keybindings~.

#+begin_src emacs-lisp
  (use-package bind-key
    :demand t
    :bind
    (:prefix-map ross/files-map
     :prefix "C-c f")
    :bind
    (:prefix-map ross/toggles-map
     :prefix "C-c t")
    :config
    (defun ross/unbind-all (fn)
      "Unbinds a function everywhere."
      (dolist (key (where-is-internal fn nil))
        (unbind-key key))))
#+end_src

*** Diminish
:PROPERTIES:
:CUSTOM_ID: diminish
:END:

We also want to "diminish" most minor-mode indicators on the mode
line.  They're only interesting if they're in an unexpected state.

#+begin_src emacs-lisp
  (use-package diminish :ensure t)
#+end_src

** Path setup
:PROPERTIES:
:CUSTOM_ID: path-setup
:END:

Launching Emacs from the MacOS dock does not source my shell config,
which leads to my Nix profile not being on the ~$PATH~, which leads to
errors, or worse, trying to install the execrable Xcode.

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :demand t
    :if (memq window-system '(mac ns x))
    :config
    (exec-path-from-shell-initialize))
#+end_src

* General customization
:PROPERTIES:
:CUSTOM_ID: general-customization
:END:

I spun my wheels for a while over how to arrange my customizations,
ignoring that Emacs has already done most of that work!  I don't use
Emacs' customize interface, preferring this version-controlled,
literate config.  However, its tree of ~defgroups~ is pretty
reasonable, and more importantly, stops me from agonizing over them.
This structure is modeled after that.

** Editing
:PROPERTIES:
:CUSTOM_ID: editing
:END:
*** Editing basics
:PROPERTIES:
:CUSTOM_ID: editing-basics
:END:
**** Character radix
:PROPERTIES:
:CUSTOM_ID: character-radix
:END:

Make =C-q= read a hex sequence instead of the default octal.  Obscure,
but I know more characters by their hex codes.  This is also
consistent with =C-x 8 <RET>=, which is more chars, but offers
minibuffer completion.

#+begin_src emacs-lisp
  (setopt read-quoted-char-radix 16)
#+end_src

**** Mark ring
:PROPERTIES:
:CUSTOM_ID: mark-ring
:END:

The mark ring is the trail of breadcrumbs we leave with various
commands.  Vernon Grant gives a [[https://vernon-grant.com/discovering-emacs/efficiency-with-the-mark-ring/][good tutorial]] in his Discovering Emacs
series.

=set-mark-command-repeat-pop= means we only need to hit ~C-u~ or ~C-x~
once before subsequent ~C-SPC~, which makes it much nicer to navigate.

#+begin_src emacs-lisp
  (setopt set-mark-command-repeat-pop t)
#+end_src

*** Indent
:PROPERTIES:
:CUSTOM_ID: indent
:END:

Tabs are the devil's whitespace.

#+begin_src
  (use-package simple
    :config
    (setq-default indent-tabs-mode nil))
#+end_src

*** Killing
:PROPERTIES:
:CUSTOM_ID: killing
:END:

Put the clipboard on the kill ring before killing something else.
Emacs isn't as violent as it sometimes sounds, I swear.

We also don't want to clutter the ring with consecutively duplicate
values.

#+begin_src emacs-lisp
  (use-package simple
    :custom
    (save-interprogram-paste-before-kill t)
    (kill-do-not-save-duplicates t))
#+end_src

** Convenience
:PROPERTIES:
:CUSTOM_ID: convenience
:END:
*** Completion
:PROPERTIES:
:CUSTOM_ID: completion
:END:
**** Copilot
:PROPERTIES:
:CUSTOM_ID: copilot
:END:

I think Copilot's training was unethical, and I'm skeptical of its
utility, but I need to get some experience with it.

~always~ in ~copilot-disable-predicates~ turns off _automatic_
completion.  We can still reach it from ~M-`~, which is chosen to be
close to ~M-TAB~ and bound to a menubar command I don't ever use.

#+begin_src emacs-lisp
  (use-package copilot
    :ensure t
    :custom
    (copilot-disable-predicates '(always))
    :hook
    (prog-mode . copilot-mode)
    :bind
    ("M-`" . copilot-complete)
    :bind
    (:map ross/toggles-map
     ("`" . copilot-mode))
    :bind
    (:map copilot-completion-map
     ("C-g" .  'copilot-clear-overlay)
     ("M-p" . 'copilot-previous-completion)
     ("M-n" . 'copilot-next-completion)
     ("<tab>" . 'copilot-accept-completion)
     ("M-f" . 'copilot-accept-completion-by-word)
     ("M-<return>" . 'copilot-accept-completion-by-line)))
#+end_src

It's not in MELPA, but it's a trivial build:

#+begin_src nix :noweb-ref emacs-copilot
  let
    copilot-lisp = epkgs.trivialBuild {
      pname = "copilot-lisp";
      src = inputs.copilot-el;
      packageRequires = [
	epkgs.dash
	epkgs.editorconfig
	epkgs.s
      ];
    };
    copilot-dist = pkgs.stdenv.mkDerivation {
      name = "copilot-dist";
      src = inputs.copilot-el;
      installPhase = ''
	LISPDIR=$out/share/emacs/site-lisp
	mkdir -p $LISPDIR
	cp -R dist $LISPDIR
      '';
    };
  in
  pkgs.symlinkJoin {
    name = "jinx";
    paths = [ copilot-lisp copilot-dist ];
  }
#+end_src

It also depends on Node.

#+begin_src nix :noweb-ref emacs-home-packages
  ({ pkgs, ...}: {
    home.packages = [ pkgs.nodejs ];
  })
#+end_src

*** Corfu
:PROPERTIES:
:CUSTOM_ID: corfu
:END:
We use [[https://github.com/minad/corfu][Corfu]] for small, in-buffer popups of completion candidates.
Autocompletion of method names in code is a classic use case.

#+begin_src emacs-lisp
  (use-package corfu
    :ensure t
    :hook (on-first-buffer . global-corfu-mode))
#+end_src

*** Exiting
:PROPERTIES:
:CUSTOM_ID: exiting
:END:

I'd usually rather exit Slack, to be quite honest.

#+begin_src emacs-lisp
  (setopt confirm-kill-emacs 'yes-or-no-p)
#+end_src

*** Display line numbers
:PROPERTIES:
:CUSTOM_ID: display-line-numbers
:END:

~display-line-numbers~ is a more performant replacement for the
venerable old ~linum~.  We turn it on for program and configuration
modes.

#+begin_src emacs-lisp
  (use-package display-line-numbers
    :custom
    (display-line-numbers-widen t)
    :hook
    ((prog-mode conf-mode) . display-line-numbers-mode))
#+end_src

*** Highlight line
:PROPERTIES:
:CUSTOM_ID: highlight-line
:END:

Highlight the current line, only in the current buffer.

#+begin_src emacs-lisp
  (use-package hl-line
    :hook (on-first-buffer . global-hl-line-mode))
#+end_src

*** ffap
:PROPERTIES:
:CUSTOM_ID: ffap
:END:

~ffap~, short for "find file at point," guesses a default file from the
point.  =ffap-bindings= rebinds several commands with ffap equivalents.

#+begin_src emacs-lisp
  (use-package ffap
    :hook (on-first-input . ffap-bindings))
#+end_src

ffap invokes ~gcc~ and ~g++~, which is fine, except on a Mac without
Xcode.  That brings up a dreaded dialog box.

#+begin_src nix :noweb-ref emacs-home-packages
  ({ pkgs, ...}: { home.packages = [ pkgs.gcc ]; })
#+end_src

*** Persist state
:PROPERTIES:
:CUSTOM_ID: persist-state
:END:

[[https://codeberg.org/bram85/emacs-persist-state.git][Persist State]] flushes state that is normally flushed in
~kill-emacs-hook~, which I'm trying not to call until I die.

#+begin_src emacs-lisp
  (use-package persist-state
    :ensure t
    :hook
    (on-first-input . persist-state-mode))
#+end_src

*** Whitespace butler
:PROPERTIES:
:CUSTOM_ID: whitespace-butler
:END:

I like builtin packages, but I like minimal diffs more.  [[https://github.com/lewang/ws-butler][ws-butler]] is
"unobtrusive", which wins the day for me.

#+begin_quote
- Only lines touched get trimmed. If the white space at end of buffer
  is changed, then blank lines at the end of buffer are truncated
  respecting =require-final-newline=.
- Trimming only happens when saving.
#+end_quote

#+begin_src emacs-lisp
  (use-package ws-butler
    :ensure t
    :hook (on-first-buffer . ws-butler-global-mode)
    :diminish)
#+end_src

** Files
:PROPERTIES:
:CUSTOM_ID: files
:END:

*** Lock files
:PROPERTIES:
:CUSTOM_ID: lock-files
:END:

On single-user environments, as we tend to run Emacs these days, those
~.#*~ files are more likely to confuse some other program as they are
to protect us from conflicting edits.

#+begin_src emacs-lisp
  (setopt create-lockfiles nil)
#+end_src

*** Auto-revert
:PROPERTIES:
:CUSTOM_ID: auto-revert
:END:

#+begin_src emacs-lisp
  (use-package autorevert
    :diminish auto-revert-mode
    :hook (on-first-buffer . global-auto-revert-mode)
    :custom
    (global-auto-revert-non-file-buffers t))
#+end_src

*** Recent files
:PROPERTIES:
:CUSTOM_ID: recent-files
:END:

This maintains a list of recent files, as we often find in other
applications.  I wonder if it can or should be integrated with MacOS'
list of recent files?

#+begin_src emacs-lisp
  (use-package recentf
    :hook (on-first-file-hook . recentf-mode)
    :bind
    (:map ross/files-map
     ("r" . recentf-open)))
#+end_src
** Text
:PROPERTIES:
:CUSTOM_ID: text
:END:

*** Case
:PROPERTIES:
:CUSTOM_ID: case
:END:
**** DWIM case
:PROPERTIES:
:CUSTOM_ID: dwim-case
:END:

These do-what-I-mean bindings are newer than the classic keybindings,
but a better default.

#+begin_src emacs-lisp
  (use-package emacs
    :bind
    ([remap capitalize-word] . capitalize-dwim)
    ([remap downcase-word] . downcase-dwim)
    ([remap upcase-word] . upcase-dwim))
#+end_src

**** Title case
:PROPERTIES:
:CUSTOM_ID: title-case
:END:

Gosh, I wish I'd had this when I was so active on [[https://musicbrainz.org/][MusicBrainz]].

#+begin_src emacs-lisp
  (use-package titlecase
    :ensure t
    :defer t)
#+end_src

*** Jinx
:PROPERTIES:
:CUSTOM_ID: jinx
:END:

[[https://github.com/minad/jinx][Jinx]] is a just-in-time spell checker.

#+begin_src emacs-lisp
  (use-package jinx
    :ensure t
    :hook (on-first-buffer . global-jinx-mode)
    :bind
    ([remap ispell-word] . jinx-correct)
    :bind
    (:map ross/toggles-map
     ("$" . jinx-mode)))
#+end_src

This one requires a Nix build, [[https://github.com/GTrunSec/hive/blob/ce7c0087a055fb3f91a402ec0d2caeb4a3579d5f/nix/emacs/homeModules/packages.nix#L16][inspired by hive-std]]:

#+begin_src nix :noweb-ref emacs-jinx
  let
    jinx-lisp = epkgs.trivialBuild {
      pname = "jinx-lisp";
      src = inputs.jinx;
      packageRequires = [ epkgs.compat ];
    };
    jinx-mod = pkgs.stdenv.mkDerivation {
      name = "jinx-mod";
      src = inputs.jinx;
      buildInputs = [ pkgs.enchant2 ];
      buildPhase = ''
	cc -I. -O2 -Wall -Wextra -fPIC -shared -o jinx-mod.dylib jinx-mod.c \
	  -I${pkgs.enchant2.dev}/include/enchant-2 -lenchant-2
      '';
      installPhase = ''
	LISPDIR=$out/share/emacs/site-lisp
	install -d $LISPDIR
	install *.dylib $LISPDIR
      '';
    };
  in
    pkgs.symlinkJoin {
      name = "jinx";
      paths = [ jinx-lisp jinx-mod ];
    }
#+end_src

Let's not forget a dictionary.

#+begin_src nix :noweb-ref emacs-home-packages
  ({ pkgs, ...}: {
    home.packages = [
      pkgs.nuspell
      pkgs.hunspellDicts.en_US
    ];
  })
#+end_src

*** Outlines
:PROPERTIES:
:CUSTOM_ID: outlines
:END:
**** Org
:PROPERTIES:
:CUSTOM_ID: org
:END:

***** ox-hugo
:PROPERTIES:
:CUSTOM_ID: ox-hugo
:END:

We use [[https://github.com/kaushalmodi/ox-hugo][ox-hugo]] for publishing.

=ross/ox-hugo-update-lastmod= can be used to update the timestamp of
the exported tree at the current point.

#+begin_src emacs-lisp
  (use-package ox-hugo
    :ensure t
    :after org
    :config
    (defun ross/ox-hugo-update-lastmod ()
      "Updates the EXPORT_HUGO_LAST_MOD property of the nearest element
  with EXPORT_FILE_NAME."
      (interactive)
        (save-excursion
          (when-let* ((elem (car (org-hugo--get-elem-with-prop :EXPORT_FILE_NAME)))
                      (begin (org-element-property :begin elem))
                      (time (format-time-string (org-time-stamp-format t) (current-time))))
            (org-entry-put begin "EXPORT_HUGO_LASTMOD" time)))))
#+end_src

***** ox-slack
:PROPERTIES:
:CUSTOM_ID: ox-slack
:END:

Mostly useful for =org-slack-export-to-clipboard-as-slack=.

#+begin_src emacs-lisp
  (use-package ox-slack
    :ensure t
    :after org
    :bind
    (:map org-mode-map
     :prefix-map ross/org-mode-map
     :prefix "C-c m"
     ("w" . org-slack-export-to-clipboard-as-slack)))
#+end_src

Apply [[https://github.com/titaniumbones/ox-slack/pull/9][this patch]] to fix the syntax for links.  In Slack, turn on
"Format messages with markup" in Advanced settings for link support.

#+begin_src nix :noweb-ref emacs-ox-slack
  epkgs.ox-slack.overrideAttrs(old: {
    patches = [ ../../src/emacs/ox-slack/github-9.patch ];
  })
#+end_src

*** Subword mode
:PROPERTIES:
:CUSTOM_ID: subword-mode
:END:

Subword mode helps us move around camel-case languages, and is mostly
configured as a hook in those major modes.  The only thing we
customize about it is not wanting it cluttering the mode line.

#+begin_src emacs-lisp
  (use-package subword
    :defer t
    :diminish)
#+end_src
*** Counting words
:PROPERTIES:
:CUSTOM_ID: counting-words
:END:

The default binding of =M-== is ~count-words-region~.  The newer
~count-words~ counts the buffer when there's no active region.

#+begin_src emacs-lisp
  (bind-key [remap count-words-region] 'count-words)
#+end_src

** Data
:PROPERTIES:
:CUSTOM_ID: data
:END:

*** Save place
:PROPERTIES:
:CUSTOM_ID: save-place
:END:

This mode saves our place for when we revisit a file.

#+begin_src emacs-lisp
  (use-package saveplace
    :hook (on-first-buffer . save-place-mode))
#+end_src

** External
:PROPERTIES:
:CUSTOM_ID: external
:END:
*** Processes
:PROPERTIES:
:CUSTOM_ID: processes
:END:
*** RFC mode
:PROPERTIES:
:CUSTOM_ID: rfc-mode
:END:

As an http4s author, I refer to RFCs constantly.

#+begin_src emacs-lisp
  (use-package rfc-mode
    :ensure t
    :defer t)
#+end_src

**** Envrc
:PROPERTIES:
:CUSTOM_ID: envrc
:END:

I maintain a minimal home environment and push as much as I can to Nix
flakes.  This insulates me from conflicting dependencies, makes my
projects more portable, and helps me share with Nix-enabled teammates.

Where possible, I add an ~.envrc~ file to load the environment from
the flake.

#+begin_src emacs-lisp
  (use-package envrc
    :ensure t
    :hook (on-first-file . envrc-global-mode))
#+end_src

** Programming
:PROPERTIES:
:CUSTOM_ID: programming
:END:
*** Languages
:PROPERTIES:
:CUSTOM_ID: languages
:END:


**** C#
:PROPERTIES:
:CUSTOM_ID: c
:END:

I am not a C# developer, but I've been known to interview them.

#+begin_src emacs-lisp
  (use-package csharp-mode
    :mode ((rx ".cs" eos) . 'csharp-ts-mode)
    :hook (csharp-ts-mode . subword-mode))
#+end_src

**** Lisp
:PROPERTIES:
:CUSTOM_ID: lisp
:END:

I would like my property lists to align not like this

#+begin_src emacs-lisp :tangle no
  (:prefix-map ross/git-map
               :prefix "C-c g")
#+end_src

but like this:

#+begin_src emacs-lisp :tangle no
  (:prefix-map ross/git-map
   :prefix "C-c g")
#+end_src

The answer is almost verbatim from [[https://emacs.stackexchange.com/a/52789][Stack Overflow]], but put in a
~use-package~ and changed to my namespace.  I also applied the
"bonus," because my primary itch is =use-package= bindings.

#+begin_src emacs-lisp
  (use-package lisp-mode
    :defer
    :config
    (defun ross/calculate-lisp-indent (&optional parse-start)
      "Add better indentation for quoted and backquoted lists."
      ;; This line because `calculate-lisp-indent-last-sexp` was defined with `defvar`
      ;; with it's value ommited, marking it special and only defining it locally. So
      ;; if you don't have this, you'll get a void variable error.
      (defvar calculate-lisp-indent-last-sexp)
      (save-excursion
        (beginning-of-line)
        (let ((indent-point (point))
              state
              ;; setting this to a number inhibits calling hook
              (desired-indent nil)
              (retry t)
              calculate-lisp-indent-last-sexp containing-sexp)
          (cond ((or (markerp parse-start) (integerp parse-start))
                 (goto-char parse-start))
                ((null parse-start) (beginning-of-defun))
                (t (setq state parse-start)))
          (unless state
            ;; Find outermost containing sexp
            (while (< (point) indent-point)
              (setq state (parse-partial-sexp (point) indent-point 0))))
          ;; Find innermost containing sexp
          (while (and retry
                      state
                      (> (elt state 0) 0))
            (setq retry nil)
            (setq calculate-lisp-indent-last-sexp (elt state 2))
            (setq containing-sexp (elt state 1))
            ;; Position following last unclosed open.
            (goto-char (1+ containing-sexp))
            ;; Is there a complete sexp since then?
            (if (and calculate-lisp-indent-last-sexp
                     (> calculate-lisp-indent-last-sexp (point)))
                ;; Yes, but is there a containing sexp after that?
                (let ((peek (parse-partial-sexp calculate-lisp-indent-last-sexp
                                                indent-point 0)))
                  (if (setq retry (car (cdr peek))) (setq state peek)))))
          (if retry
              nil
            ;; Innermost containing sexp found
            (goto-char (1+ containing-sexp))
            (if (not calculate-lisp-indent-last-sexp)
                ;; indent-point immediately follows open paren.
                ;; Don't call hook.
                (setq desired-indent (current-column))
              ;; Find the start of first element of containing sexp.
              (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
              (cond ((looking-at "\\s(")
                     ;; First element of containing sexp is a list.
                     ;; Indent under that list.
                     )
                    ((> (save-excursion (forward-line 1) (point))
                        calculate-lisp-indent-last-sexp)
                     ;; This is the first line to start within the containing sexp.
                     ;; It's almost certainly a function call.
                     (if (or
                          ;; Containing sexp has nothing before this line
                          ;; except the first element. Indent under that element.
                          (= (point) calculate-lisp-indent-last-sexp)

                          ;; First sexp after `containing-sexp' is a keyword. This
                          ;; condition is more debatable. It's so that I can have
                          ;; unquoted plists in macros. It assumes that you won't
                          ;; make a function whose name is a keyword.
                          (when-let (char-after (char-after (1+ containing-sexp)))
                            (char-equal char-after ?:))

                          ;; Check for quotes or backquotes around.
                          (let* ((positions (elt state 9))
                                 (last (car (last positions)))
                                 (rest (reverse (butlast positions)))
                                 (any-quoted-p nil)
                                 (point nil))
                            (or
                             (when-let (char (char-before last))
                               (or (char-equal char ?')
                                   (char-equal char ?`)))
                             (progn
                               (while (and rest (not any-quoted-p))
                                 (setq point (pop rest))
                                 (setq any-quoted-p
                                       (or
                                        (when-let (char (char-before point))
                                          (or (char-equal char ?')
                                              (char-equal char ?`)))
                                        (save-excursion
                                          (goto-char (1+ point))
                                          (looking-at-p
                                           "\\(?:back\\)?quote[\t\n\f\s]+(")))))
                               any-quoted-p))))
                         ;; Containing sexp has nothing before this line
                         ;; except the first element.  Indent under that element.
                         nil
                       ;; Skip the first element, find start of second (the first
                       ;; argument of the function call) and indent under.
                       (progn (forward-sexp 1)
                              (parse-partial-sexp (point)
                                                  calculate-lisp-indent-last-sexp
                                                  0 t)))
                     (backward-prefix-chars))
                    (t
                     ;; Indent beneath first sexp on same line as
                     ;; `calculate-lisp-indent-last-sexp'.  Again, it's
                     ;; almost certainly a function call.
                     (goto-char calculate-lisp-indent-last-sexp)
                     (beginning-of-line)
                     (parse-partial-sexp (point) calculate-lisp-indent-last-sexp
                                         0 t)
                     (backward-prefix-chars)))))
          ;; Point is at the point to indent under unless we are inside a string.
          ;; Call indentation hook except when overridden by lisp-indent-offset
          ;; or if the desired indentation has already been computed.
          (let ((normal-indent (current-column)))
            (cond ((elt state 3)
                   ;; Inside a string, don't change indentation.
                   nil)
                  ((and (integerp lisp-indent-offset) containing-sexp)
                   ;; Indent by constant offset
                   (goto-char containing-sexp)
                   (+ (current-column) lisp-indent-offset))
                  ;; in this case calculate-lisp-indent-last-sexp is not nil
                  (calculate-lisp-indent-last-sexp
                   (or
                    ;; try to align the parameters of a known function
                    (and lisp-indent-function
                         (not retry)
                         (funcall lisp-indent-function indent-point state))
                    ;; If the function has no special alignment
                    ;; or it does not apply to this argument,
                    ;; try to align a constant-symbol under the last
                    ;; preceding constant symbol, if there is such one of
                    ;; the last 2 preceding symbols, in the previous
                    ;; uncommented line.
                    (and (save-excursion
                           (goto-char indent-point)
                           (skip-chars-forward " \t")
                           (looking-at ":"))
                         ;; The last sexp may not be at the indentation
                         ;; where it begins, so find that one, instead.
                         (save-excursion
                           (goto-char calculate-lisp-indent-last-sexp)
                           ;; Handle prefix characters and whitespace
                           ;; following an open paren.  (Bug#1012)
                           (backward-prefix-chars)
                           (while (not (or (looking-back "^[ \t]*\\|([ \t]+"
                                                         (line-beginning-position))
                                           (and containing-sexp
                                                (>= (1+ containing-sexp) (point)))))
                             (forward-sexp -1)
                             (backward-prefix-chars))
                           (setq calculate-lisp-indent-last-sexp (point)))
                         (> calculate-lisp-indent-last-sexp
                            (save-excursion
                              (goto-char (1+ containing-sexp))
                              (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
                              (point)))
                         (let ((parse-sexp-ignore-comments t)
                               indent)
                           (goto-char calculate-lisp-indent-last-sexp)
                           (or (and (looking-at ":")
                                    (setq indent (current-column)))
                               (and (< (line-beginning-position)
                                       (prog2 (backward-sexp) (point)))
                                    (looking-at ":")
                                    (setq indent (current-column))))
                           indent))
                    ;; another symbols or constants not preceded by a constant
                    ;; as defined above.
                    normal-indent))
                  ;; in this case calculate-lisp-indent-last-sexp is nil
                  (desired-indent)
                  (t
                   normal-indent))))))
    (advice-add #'calculate-lisp-indent :override #'ross/calculate-lisp-indent))
#+end_src

***** Compilation
:PROPERTIES:
:CUSTOM_ID: compilation
:END:

I get a bunch of asynchronous warnings from native compilation in a
~*Warnings*~ popup.  It's nice that they're there, but unless they're
an error, I don't need them all up in my business.

#+begin_src emacs-lisp
  (use-package comp
    :custom
    (native-comp-async-report-warnings-errors 'silent))
#+end_src


**** Nix
:PROPERTIES:
:CUSTOM_ID: nix
:END:

#+begin_src emacs-lisp
  (use-package nix-mode
    :ensure t
    :defer t)
#+end_src
**** Scala
:PROPERTIES:
:CUSTOM_ID: scala
:END:

Much of this configuration starts from the [[https://scalameta.org/metals/docs/editors/emacs/][Metals guide]].

#+begin_warning
This doesn't work well with Scala 3's Significant Whitespace
Traveshamockery.  Once we're ready for that, we'll take a look at
[[https://github.com/KaranAhlawat/scala-ts-mode/issues/1#issuecomment-1573884094][scala-ts-mode]].
#+end_warning

#+begin_src emacs-lisp
  (use-package scala-mode
    :ensure t
    :interpreter ("scala" . scala-mode)
    :hook
    (scala-mode . eglot-ensure)
    (scala-mode . subword-mode))

  (use-package sbt-mode
    :ensure t
    :commands sbt-start sbt-command)
#+end_src

**** XML
:PROPERTIES:
:CUSTOM_ID: xml
:END:

[[https://github.com/tali713/esxml][esxml]] essentially turns Lisp into an XML (or XHTML) templating engine.

#+begin_src emacs-lisp
  (use-package esxml
    :ensure t
    :defer t)
#+end_src


*** Tools
:PROPERTIES:
:CUSTOM_ID: tools
:END:

**** Dumb jump
:PROPERTIES:
:CUSTOM_ID: dumb-jump
:END:

[[https://github.com/jacktasia/dumb-jump][dumb-jump]] is dumber than LSP, but it's a lot less fussy and makes for
a wonderful fallback option.

~git-grep~ is not working for me.  It appears to be [[https://github.com/jacktasia/dumb-jump/issues/428][option rot]].

#+begin_src emacs-lisp
  (use-package dumb-jump
    :ensure t
    :config
    (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
    :custom
    (dumb-jump-force-searcher 'rg))
#+end_src

Make sure ripgrep is available.

#+begin_src nix :noweb-ref emacs-home-packages
  ({ pkgs, ...}: { home.packages = [ pkgs.ripgrep ]; })
#+end_src

**** Git
:PROPERTIES:
:CUSTOM_ID: git
:END:
***** Magit
:PROPERTIES:
:CUSTOM_ID: magit
:END:

I have known people to leave Emacs, but continuing to use [[https://magit.vc/][Magit]] for
version control.  It's that good.

I am giving built-ins the benefit of the doubt in this config, and
would like to get into ~vc-mode~.  But I'm an advanced enough Git user
that something tailor-made carries its weight here.

#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :defer 1
    :functions ross/magit-clone-read-args-a
    :bind
    (:prefix-map ross/git-map
     :prefix "C-c g"
     ("g" . magit-status)
     ("c" . magit-clone))
    :custom
    (magit-clone-default-directory "~/src/")
    (magit-no-message (list "Turning on magit-auto-revert-mode..."))
    :config
    (defun ross/magit-clone-read-args-a (orig-fun &rest args)
      "Sets `vertico-preselect' to `prompt' when cloning repos, so we
  clone to the default prompted directory, and not some random
  existing directory under `magit-clone-default-directory'."
      (let ((vertico-preselect 'prompt))
        (apply orig-fun args)))
    (advice-add 'magit-clone-read-args :around #'ross/magit-clone-read-args-a))
#+end_src

***** Git-Link
:PROPERTIES:
:CUSTOM_ID: git-link
:END:

[[https://github.com/sshaw/git-link/][git-link]] grabs links to lines, regions, commits, or home pages.

#+begin_src emacs-lisp
  (use-package git-link
    :ensure t
    :custom
    (git-link-use-commit t)
    (git-link-use-single-line-number t)
    :commands (git-link git-link-commit git-link-homepage))
#+end_src

***** Git-Related
:PROPERTIES:
:CUSTOM_ID: git-related
:END:

[[https://macroexpand.net/pages/git-related.html][~git-related~]] sorts files in a project by a similarity score derived
from how often they change in the same commit.

#+begin_src emacs-lisp
  (use-package git-related
    :bind
    (:map ross/files-map
     ("g" . git-related-find-file)))
#+end_src

The original is not in a public Git repository, so I [[https://codeberg.org/rossabaker/git-related][forked it]].

I don't prefer the way it propertizes the string with the score.  The
main thing I want is the sort, so I lightly customized it.  The score
might still be compelling as an ~:annotation-function~.

#+begin_src nix :noweb-ref emacs-git-related
  epkgs.trivialBuild {
    pname = "git-related";
    src = inputs.git-related;
  }
#+end_src

The sort order is customized in [[*Vertico multiform][vertico-multiform]].

**** Treesitter
:PROPERTIES:
:CUSTOM_ID: treesitter
:END:

[[https://github.com/renzmann/treesit-auto][~treesit-auto~]] finds treesitter modes by naming convention.

#+begin_src emacs-lisp
  (use-package treesit-auto
    :ensure t
    :demand t
    :config
    (global-treesit-auto-mode))
#+end_src

**** UUID Generation
:PROPERTIES:
:CUSTOM_ID: uuid-generation
:END:

#+begin_src emacs-lisp
  (use-package uuidgen
    :ensure t
    :defer t)
#+end_src

**** Xref
:PROPERTIES:
:CUSTOM_ID: xref
:END:

Regardless of LSP or dumb-jump, we want Vertico to handle when
multiple definitions are found.

#+begin_src emacs-lisp
  (use-package xref
    :defer
    :custom
    (xref-show-definitions-function #'xref-show-definitions-completing-read))
#+end_src
** Applications
:PROPERTIES:
:CUSTOM_ID: applications
:END:
*** Dictionary
:PROPERTIES:
:CUSTOM_ID: dictionary
:END:

The ~M-#~ keybinding is dubious because it's not reserved, but it's
[[https://www.masteringemacs.org/article/wordsmithing-in-emacs][good enough for Mickey Petersen]].

#+begin_src emacs-lisp
  (use-package dictionary
    :bind
    ("M-#" . dictionary-lookup-definition))
#+end_src

Until I find a working dictd for MacOS on Nix, we'll sigh heavily and
use dict.org.

#+begin_src emacs-lisp
  (use-package dictionary
    :if (memq window-system '(mac ns x))
    :custom
    (dictionary-server "dict.org"))
#+end_src

*** Language server protocol
:PROPERTIES:
:CUSTOM_ID: language-server-protocol
:END:

We're going to give [[https://joaotavora.github.io/eglot/][eglot]] a try now that it's built into Emacs.  It's
a bit more minimalist than the excellent [[https://emacs-lsp.github.io/lsp-mode/][lsp-mode]].

#+begin_src emacs-lisp
  (use-package eglot :defer t)
#+end_src

** Development
:PROPERTIES:
:CUSTOM_ID: development
:END:
*** Extensions
:PROPERTIES:
:CUSTOM_ID: extensions
:END:
**** htmlize
:PROPERTIES:
:CUSTOM_ID: htmlize
:END:

[[https://github.com/hniksic/emacs-htmlize/blob/master/htmlize.el][=htmlize=]] provides syntax highlighting for our code snippets when
exported to HTML.

#+begin_src emacs-lisp
  (use-package htmlize
    :ensure t
    :after ox-html)
#+end_src

** Environment
:PROPERTIES:
:CUSTOM_ID: environment
:END:
*** Frames
:PROPERTIES:
:CUSTOM_ID: frames
:END:

I like tiled windows more than I need Emacs to maintain a static
number of columns and rows.

#+begin_src emacs-lisp
  (setopt frame-inhibit-implied-resize t)
#+end_src

**** Cursor
:PROPERTIES:
:CUSTOM_ID: cursor
:END:

I like a non-blinking bar cursor.

#+begin_src emacs-lisp
  (setopt cursor-type 'bar)
  (use-package frame
    :config
    (blink-cursor-mode -1))
#+end_src

**** Mode line
:PROPERTIES:
:CUSTOM_ID: mode-line
:END:
***** Column number
:PROPERTIES:
:CUSTOM_ID: column-number
:END:

#+begin_src emacs-lisp
  (use-package simple
    :hook
    (on-first-buffer . column-number-mode))
#+end_src

***** Size indication
:PROPERTIES:
:CUSTOM_ID: size-indication
:END:
Put the buffer size in the mode line.  coreutils use binary
(base 1024) units, so I will too.  I mostly wanted to see if I could.
Of course I could.  This is Emacs.

#+begin_src emacs-lisp
  (defun ross/mode-line-binary-size-indication ()
    "Replaces the size indication in the mode line with base 1024 units."
    (require 'cl-seq)
    (setopt mode-line-position
	    (cl-subst-if
	     '(size-indication-mode
	       (8 " of " (:eval (file-size-human-readable (buffer-size) 'iec "" "B"))))
	     (lambda (x) (and (listp x) (eq 'size-indication-mode (car x))))
	     mode-line-position)))
  (add-hook 'on-first-buffer-hook #'ross/mode-line-binary-size-indication)
  (add-hook 'on-first-buffer-hook #'size-indication-mode)
#+end_src

**** Scroll bars
:PROPERTIES:
:CUSTOM_ID: scroll-bars
:END:

The mode line tells us where we're at, and we mostly eschew the mouse.

#+begin_src emacs-lisp
  (use-package scroll-bar
    :config
    (scroll-bar-mode -1))
#+end_src

**** Tool bars
:PROPERTIES:
:CUSTOM_ID: tool-bars
:END:

The much despised tool bar is not a terrible default for the Emacs
neophyte, but I'm old and grizzled.

#+begin_src emacs-lisp
  (use-package tool-bar
    :config
    (tool-bar-mode -1))
#+end_src

**** Minimization: let's not
:PROPERTIES:
:CUSTOM_ID: minimization-let's-not
:END:

I don't much care for minimizing windows in the first place, and
particularly not my favorite window with a keybinding that's too easy to hit.

#+begin_src emacs-lisp
  (use-package frame
    :bind
    ("C-z" . nil))
#+end_src

**** Beep beep, your ass
:PROPERTIES:
:CUSTOM_ID: beep-beep-your-ass
:END:

Decades ago, there was a meme of Wile E. Coyote, having finally caught
Road Runner, saying "Beep beep your ass."  This comes from
approximately the same era as the last time anyone wanted a system
bell.

#+begin_src emacs-lisp
  (use-package mode-line-bell
    :ensure
    :hook (on-first-input . mode-line-bell-mode))
#+end_src

*** Faces
:PROPERTIES:
:CUSTOM_ID: faces
:END:

**** Fontaine
:PROPERTIES:
:CUSTOM_ID: fontaine
:END:

I give an increasing number of live presentations at work.  The
[[https://protesilaos.com/emacs/fontaine][Fontaine]] package lets me scale up the font for screen sharing, and
return to normalcy.

[[https://www.ibm.com/plex/][IBM Plex Mono]] is used if it's installed.  Their [[https://www.ibm.com/design/language/typography/type-specs-ui/][~code-02~ utility
claas]] suggests a line height of 20px, which translates to a
=line-spacing= of 6.  This is too much.  Particularly, the cursor gets
distractingly tall when the point is not at a character.  [[https://lists.gnu.org/archive/html/bug-gnu-emacs/2015-11/msg00236.html][Bug#21835]] is
related.  ~0.25~ gives the text room to breathe, without the cursor
growing and shrinking by leaps and bounds.

Note that Emacs line heights are "printer's points," which are ten to
the rest of the world's points.

#+begin_src emacs-lisp
  (use-package fontaine
    :ensure t
    :demand t
    :bind
    (:map ross/toggles-map
     ("p" . ross/presentation-mode))
    :custom
    (fontaine-presets
     `((regular
        :default-height 140
        :line-spacing 0.25)
       (presentation
        :default-height 210
        :line-spacing 0.125)
       (t ;; defaults
        :default-family
        ,(cond
          ((find-font (font-spec :name "IBM Plex Mono"))
           "IBM Plex Mono")
          ("Monospace")))))
    :config
    (fontaine-set-preset (or fontaine-current-preset 'regular))
    (define-minor-mode ross/presentation-mode
      "Toggles global ross/presentation-mode."
      nil
      :global t
      (if ross/presentation-mode
          (fontaine-set-preset 'presentation)
        (fontaine-set-preset 'regular))))
#+end_src

**** Modus themes
:PROPERTIES:
:CUSTOM_ID: modus-themes
:END:

I like the [[https://protesilaos.com/emacs/modus-themes][modus-themes]].  They are built into modern Emacs, but the
author continues to work on them, so we grab them from ELPA with
~:ensure t~.

#+begin_src emacs-lisp
  (use-package modus-themes
    :ensure t
    :config
    (load-theme 'modus-operandi :no-confirm))
#+end_src

*** Initialization
:PROPERTIES:
:CUSTOM_ID: initialization
:END:

I don't need a dashboard and I know where the manuals are.  I prefer a
quiet startup.

#+begin_src emacs-lisp
  (use-package "startup"
    :custom
    (inhibit-splash-screen t)
    (initial-major-mode 'fundamental-mode)
    (initial-scratch-message nil))
#+end_src

*** Marginalia
:PROPERTIES:
:CUSTOM_ID: marginalia
:END:

[[https://github.com/minad/marginalia][Marginalia]] annotates minibuffer completions with some useful info.

#+begin_src emacs-lisp
  (use-package marginalia
    :ensure t
    :after vertico
    :bind
    (:map minibuffer-local-map
     ("M-A" . marginalia-cycle))
    :config
    (marginalia-mode))
#+end_src

*** Minibuffer
:PROPERTIES:
:CUSTOM_ID: minibuffer
:END:
**** Consult
:PROPERTIES:
:CUSTOM_ID: consult
:END:

[[https://github.com/minad/consult][Consult]] provides several enhanced functions for ~completing-read~.  It fits nicely with [[*Vertico][Vertico]].

I generally remapped everything obvious.
~consult-yank-from-kill-ring~ as a remapping of ~yank~ proved a bit
too disorienting.

#+begin_src emacs-lisp
  (use-package consult
    :ensure t
    :bind
    ([remap switch-to-buffer] . consult-buffer)
    ([remap switch-to-buffer-other-window] . consult-buffer-other-window)
    ([remap switch-to-buffer-other-frame] . consult-buffer-other-frame)
    ([remap project-switch-to-buffer] . consult-project-buffer)
    ([remap bookmark-jump] . consult-bookmark)
    ([remap recentf-open] . consult-recent-file)
    ([remap yank] . nil)
    ([remap yank-pop] . consult-yank-pop)
    ([remap goto-line] . consult-goto-line)
    ("M-g m" . consult-mark)
    ("M-g M" . consult-global-mark)
    ("M-g o" . consult-outline)
    ("M-g i" . consult-imenu)
    ("M-g I" . consult-imenu-multi)
    ("M-s l" . consult-line)
    ("M-s L" . consult-line-multi)
    ("M-s k" . consult-keep-lines)
    ("M-s u" . consult-focus-lines)
    ("M-s r" . consult-ripgrep)
    ("M-s f" . consult-find)
    ("M-s F" . consult-locate)
    ("M-g e" . consult-compile-error)
    ("M-g f" . consult-flymake)
    ([remap repeat-complex-command] . consult-complex-command)
    ("M-s e" . consult-isearch-history)
    ([remap isearch-edit-string] . consult-isearch-history)
    ([remap next-matching-history-element] . consult-history)
    ([remap previous-matching-history-element] . consult-history)
    ([remap Info-search] . consult-info)
    :custom
    (xref-show-xrefs-function 'consult-xref)
    (xref-show-definitions-function 'consult-xref))
#+end_src

*** Menu
:PROPERTIES:
:CUSTOM_ID: menu
:END:

Dialog boxes are an unemacsian abomination.

#+begin_src emacs-lisp
  (setopt use-dialog-box nil)
#+end_src

*** Mouse
:PROPERTIES:
:CUSTOM_ID: mouse
:END:

I don't use the mouse much in Emacs, but if I do, it's the scroll
wheel.  This makes it feel less like a trip back to a time before
scroll wheels.

#+begin_src emacs-lisp
  (use-package pixel-scroll
    :hook
    (on-first-buffer . pixel-scroll-precision-mode))
#+end_src

*** Vertico
:PROPERTIES:
:CUSTOM_ID: vertico
:END:

[[https://github.com/minad/vertico][Vertico]] is a little bit nicer version of the builtin
~icomplete-vertical~.

#+begin_src emacs-lisp
  (use-package vertico
    :ensure t
    :hook (on-first-input . vertico-mode))
#+end_src

**** Vertico indexed
:PROPERTIES:
:CUSTOM_ID: vertico-indexed
:END:

~vertico-indexed~ lets us select candidates by number with =C-u RET=.
It's an alternative to ~vertico-quick~.

#+begin_src emacs-lisp
  (use-package vertico-indexed
    :after vertico
    :config (vertico-indexed-mode))
#+end_src

**** Vertico repeat
:PROPERTIES:
:CUSTOM_ID: vertico-repeat
:END:

~vertico-repeat~ resumes a prior completion session.

#+begin_src emacs-lisp
  (use-package vertico-repeat
    :after vertico
    :hook (minibuffer-setup . vertico-repeat-save)
    :bind ("M-R" . vertico-repeat))
#+end_src

**** Vertico directory
:PROPERTIES:
:CUSTOM_ID: vertico-directory
:END:

~vertico-directory~ does some smarter things when completing directories:
- =RET= continues completing in that directory instead of jumping to
  dired.
- =M-DEL= deletes whole directories at a time if the prompt ends in a
  slash.  There's a recommended binding for =DEL=, but I'd rather keep
  that deleting chars.

I never understood =vertico-directory-tidy= before [[https://kristofferbalintona.me/posts/202202211546/#niceties][this demo]].  When we
start with ~/~ or ~~/~, it cleans up the leading default prompt that's
"shadowed".

#+begin_src emacs-lisp
  (use-package vertico-directory
    :after vertico
    :bind
    (:map vertico-map
     ("RET" . vertico-directory-enter)
     ("M-DEL" . vertico-directory-delete-word))
    :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))
#+end_src

**** Vertico multiform
:PROPERTIES:
:CUSTOM_ID: vertico-multiform
:END:

#+begin_src emacs-lisp
  (use-package vertico-multiform
    :after vertico
    :custom
    (vertico-multiform-commands '((git-related-find-file (vertico-sort-function . nil))))
    :config
    (vertico-multiform-mode))
#+end_src

*** Windows
:PROPERTIES:
:CUSTOM_ID: windows
:END:

I reflexively call ~other-window~ after splitting.  [[https://macowners.club/posts/custom-functions-5-navigation/#windows-splitting][This idea]] from
Aimé Bertrand is compelling.

#+begin_src emacs-lisp
  (use-package window
    :config
    (defun ross/nav-split-and-follow-below ()
      "Split the selected window in two with the new window is bellow.
  This uses `split-window-below' but follows with the cursor."
      (interactive)
      (split-window-below)
      (other-window 1))

    (defun ross/nav-split-and-follow-right ()
      "Split the selected window in two with the new window is to the right.
  This uses `split-window-right' but follows with the cursor."
      (interactive)
      (split-window-right)
      (other-window 1))
    :bind
    ([remap split-window-below] . ross/nav-split-and-follow-below)
    ([remap split-window-right] . ross/nav-split-and-follow-right))'
#+end_src

**** Zoom
:PROPERTIES:
:CUSTOM_ID: zoom
:END:

[[https://github.com/cyrus-and/zoom][Zoom]] resizes the selected window.  It's a modernized version of
[[https://github.com/roman/golden-ratio.el][golden-ratio.el]], and indeed, we configure it to use the golden ratio.

#+begin_src emacs-lisp
  (use-package zoom
    :ensure t
    :custom
    (zoom-size ,(let ((phi (- (/ (+ 1 (sqrt 5)) 2) 1)))
		  (cons phi phi))))
#+end_src

** Help
:PROPERTIES:
:CUSTOM_ID: help
:END:
*** Which Key
:PROPERTIES:
:CUSTOM_ID: which-key
:END:

[[https://github.com/justbur/emacs-which-key][~which-key~]] pops up a menu of keybindings.  The traditional way is to
run it on a timer, but I prefer [[https://github.com/justbur/emacs-which-key#manual-activation][manual activation]].

I also relabel all my keymaps of the form ~ross/blah-map~ to ~blah~.
Neither =:prefix-docstring= nor =:menu-item= in ~bind-key~ seem to do
the trick.

#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :hook (on-first-input . which-key-mode)
    :diminish
    :custom
    (which-key-show-early-on-C-h t)
    (which-key-idle-delay most-positive-fixnum)
    (which-key-idle-secondary-delay 1e-9)
    :config
    (push `((nil . ,(rx bos "ross/" (group (1+ any)) "-map" eos)) .
            (nil . ,(rx (backref 1))))
          which-key-replacement-alist))
#+end_src

~C-h C-h~ shadows which-key with something less useful.

#+begin_src emacs-lisp
  (use-package help
    :config
    (ross/unbind-all 'help-for-help))
#+end_src

** Junk drawer
:PROPERTIES:
:CUSTOM_ID: junk-drawer
:END:

These customizations don't fit anywhere else.

*** Remove the training wheels
:PROPERTIES:
:CUSTOM_ID: remove-the-training-wheels
:END:

#+begin_src emacs-lisp
  (put 'narrow-to-region 'disabled nil)
#+end_src

* Nix module
:PROPERTIES:
:CUSTOM_ID: nix-module
:END:

This Emacs configuration is built with Nix using [[https://github.com/nix-community/emacs-overlay][emacs-overlay]] and
published to my [[file:nix-flake.org::#what's-in-the-flake][Nix flake]].

Even though Emacs 29 is not released at the time of writing, git is on
Emacs 30!  We publish an =emacs29= flake package with the desired
branch pinned via the =emacs-src= input.  It's also added to our
default overlay, so it can be used as a dependency by other packages
and apps.  The package has no configuration.

Additionally, an =emacs= flake app is created.  This builds on the
=emacs29= package with the config above to make a usable Emacs.

Finally, we add a Home Manager module based on the configured app.

#+begin_src nix :tangle ../../../gen/emacs/default.nix :noweb tangle :mkdirp yes
  { inputs, lib, moduleWithSystem, ... }: {
    imports = [
      inputs.flake-parts.flakeModules.easyOverlay
    ];
    perSystem = { config, self', inputs', pkgs, system, ... }: {
      overlayAttrs = {
	inherit (config.packages) emacs29;
      };
      packages.emacs29 = pkgs.emacs-git.overrideAttrs (old: {
	name = "emacs29";
	# It's important this starts with the major number for Nix's
	# Emacs infra.  For example, it's used to blank out archaic
	# versions of the Seq package in MELPA.
	version = "29.0-${inputs.emacs-src.shortRev}";
	src = inputs.emacs-src;
	# This doesn't apply to Emacs29.
	patches = builtins.filter (p: baseNameOf p != "bytecomp-revert.patch") old.patches;
      });
      packages.emacs-ross = pkgs.emacsWithPackagesFromUsePackage {
	package = config.packages.emacs29;
	override = epkgs: epkgs // {
	  on = epkgs.trivialBuild {
	    pname = "on.el";
	    src = inputs.on-el;
	  };
	  jinx =
	    <<emacs-jinx>>;
	  copilot =
	    <<emacs-copilot>>;
	  ox-slack =
	    <<emacs-ox-slack>>;
	  git-related =
	    <<emacs-git-related>>;
	};
	config = ./init.el;
	defaultInitFile = true;
	alwaysEnsure = false;
      };
      apps.emacs = {
	type = "app";
	program = "${config.packages.emacs-ross}/bin/emacs";
      };
    };
    flake = {
      homeManagerModules.emacs = moduleWithSystem (
	perSystem@{ config, pkgs }: {
	  imports = [
	    <<emacs-home-packages>>
	    ./load-path.nix
	  ];
	  programs.emacs = {
	    enable = true;
	    package = config.packages.emacs-ross;
	  };
	}
      );
    };
  }
#+end_src

As long as I have access to Nix, I can install and run my complete
Emacs app as a one-liner.  There's little reason for you to choose it
over a starter kit or your own configuration, but there's also nothing
stopping you!

#+begin_src sh :eval no
  nix run github:rossabaker/cromulent#emacs
#+end_src

** On-the-fly load-paths
:PROPERTIES:
:CUSTOM_ID: on-the-fly-load-paths
:END:

A disadvantage to a Nix-based Emacs config is that we have to restart
Emacs every time we install a new package.  [[https://discourse.nixos.org/t/emacs-exwm-home-manager-and-loading-new-emacs-modules/10097/3][This hack]] from the Nix
forums lets us update the =load-path= after a home-manager switch.
From the original posting, we change ~finalPackage~ to ~package~:
~finalPackage~ refers to a wrapper with an empty site-lisp.

#+begin_src nix :tangle ../../../gen/emacs/load-path.nix
  { pkgs, home, config, ... }:
  let
    cfg = config.programs.emacs;
  in
  {
    xdg.configFile."emacs/load-path.el".source = pkgs.writeText "load-path.el" ''
      (let ((default-directory (file-name-as-directory
				"${cfg.package.deps}/share/emacs/site-lisp/"))
	    (normal-top-level-add-subdirs-inode-list nil))
      (normal-top-level-add-subdirs-to-load-path))
    '';
  }
#+end_src

Finally, a convenience function to reload it:

#+begin_src emacs-lisp
  (defun ross/refresh-load-path ()
    "Refresh the load path written by home-manager to pick up new
   packages without restarting Emacs."
    (interactive)
    (load-file "~/.config/emacs/load-path.el"))
#+end_src

#+begin_src emacs-lisp
  (use-package markdown-mode
    :ensure t)
#+end_src
