#+PROPERTY: header-args :mkdirp yes
#+title: Website colophon
#+redirect_from: /configs/website/build
#+date: <2022-11-14 Mon 20:57>

[[https://rossabaker.com/][rossabaker.com]] is primarily written in [[https://orgmode.org/][Org Mode]] and exported to HTML
via [[https://orgmode.org/manual/HTML-Export.html][ox-html]].  The result is packaged with [[https://nixos.org/][Nix]].

* Local development

Most of the site is built with Emacs Lisp.  The site is assembled into
=ross-www/public-html-directory=.

#+begin_src emacs-lisp :tangle ../../../../gen/website/build.el :results silent
  (require 'ob-shell)
  (require 'ox-hugo)
  (require 'ox-publish)
  (require 'htmlize)

  (defvar ross-www/src-directory
    (expand-file-name "src" (getenv "PRJ_ROOT"))
    "Source directory for rossabaker.com.")

  (defvar ross-www/tmp-directory
    (expand-file-name "tmp" (getenv "PRJ_ROOT"))
    "Source directory for rossabaker.com.")

  (defvar ross-www/public-html-directory
    (expand-file-name "public_html" ross-www/tmp-directory)
    "Source directory for rossabaker.com.")
#+end_src

** ox-hugo Legacy

This site was originally built with [[https://ox-hugo.scripter.co/][ox-hugo]].  To build the legacy site into
`tmp/public_html`, run =ross-www/legacy-publish=.

#+begin_src emacs-lisp :tangle ../../../../gen/website/build.el :results silent
  (defun ross-www/legacy-publish ()
    "Build the legacy ox-hugo website."
    (interactive)
    (find-file (expand-file-name "org/rossabaker.org" ross-www/src-directory))
    (setq-local org-confirm-babel-evaluate nil)
    (message "Tangling legacy ox-hugo files")
    (org-babel-tangle)
    (mkdir (expand-file-name "hugo/static" ross-www/tmp-directory) t)
    (message "Exporting legacy ox-hugo pages")
    (org-hugo-export-wim-to-md t)
    (message "Running hugo")
    (let ((default-directory (or (getenv "PRJ_ROOT") (getenv "NIX_BUILD_TOP") default-directory)))
      (message "Default directory: %s" default-directory)
      (process-file (executable-find "hugo")
                    nil
                    (if (getenv "NIX_BUILD_TOP") '(:file "/dev/stdout") t)
                    nil
                    "--config"
                    (expand-file-name "hugo/config.toml" ross-www/tmp-directory)
                    "--destination"
                    ross-www/public-html-directory
                    "-F")))
#+end_src

** Redirects

[[https://www.w3.org/Provider/Style/URI][Cool URIs don't change]], but mistakes were made.  Netlify supports a
[[https://docs.netlify.com/routing/redirects/][~_redirects~ file]].  We generate one with a custom =redirect-from= file
property.

First we need a backend that knows how to parse =redirect-from=.  That
last =t= should probably be =space=, so we get more than one, but this
achieves liftoff.

#+begin_src emacs-lisp :tangle ../../../../gen/website/build.el :results silent
  (org-export-define-backend 'ross-www/redirects
    nil
    :options-alist
    '((:redirect-from "REDIRECT_FROM" nil nil t)))
#+end_src

We'll add a [[https://orgmode.org/manual/Publishing-action.html][publishing action]].  This one is unusual, in that multiple
files are being consolidated into one.  We just append to a temporary
buffer.  The =nil= project argument to =org-publish-find-property= is
dubious, but works as long as =filename= is absolute.

#+begin_src emacs-lisp :tangle ../../../../gen/website/build.el :results silent
  (defun ross-www/publish-redirects (plist filename pub-dir)
    "Publish the _redirects file."
    (let* ((buffer (get-buffer-create " *ross-www/publish-redirects*"))
           (ext (or (plist-get plist :html-extension) ".html"))
           (output-abs (with-temp-buffer
                         (insert-file-contents filename)
                         (set-visited-file-name filename t)
                         (not-modified)
                         (org-export-output-file-name ext nil pub-dir)))
           (output-rel (file-relative-name output-abs ross-www/public-html-directory))
           (output (concat "/" (string-remove-suffix "/index.html" output-rel))))
      (with-current-buffer buffer
        (when-let ((redirect-from (org-publish-find-property filename :redirect-from nil 'ross-www/redirects)))
          (insert redirect-from)
          (insert "\t")
          (insert output)
          (insert "\n")))))
#+end_src

We also need a preparation action and a completion action.  The former
creates (or clears, if existing) our temporary buffer.  The latter
writes its contents to the ~_redirects~ file.

#+begin_src emacs-lisp :tangle ../../../../gen/website/build.el :results silent
  (defun ross-www/publish-redirects-prepare (plist)
    "Creates an empty buffer for publishing redirects."
    (let ((buffer (get-buffer-create " *ross-www/publish-redirects*")))
      (with-current-buffer buffer
        (erase-buffer))))

  (defun ross-www/publish-redirects-complete (plist)
    "Writes the redirects buffer."
    (let ((buffer (get-buffer-create " *ross-www/publish-redirects*"))
          (redirects-file-name (expand-file-name "_redirects" ross-www/public-html-directory)))
      (with-current-buffer buffer
        (message "Writing redirects to %s" redirects-file-name)
        (write-file redirects-file-name)
        (kill-current-buffer))))
#+end_src

** ox-publish

We use [[https://orgmode.org/manual/Publishing.html][ox-publish]] moving forward.  It operates from a global
=org-publish-project-alist= variable, which we'll add projects to.

#+begin_src emacs-lisp :tangle ../../../../gen/website/build.el :results silent
  (add-to-list 'org-publish-project-alist
               `("rossabaker.com"
                 :base-directory ,(expand-file-name "org/" ross-www/src-directory)
                 :base-extension "org"
                 :recursive t
                 :exclude ,(rx (or "rossabaker.org" "config/" "talks/"))
                 :preparation-function ross-www/publish-redirects-prepare
                 :publishing-function (org-html-publish-to-html ross-www/publish-redirects)
                 :publishing-directory ,(expand-file-name "public_html" ross-www/tmp-directory)
                 :completion-function ross-www/publish-redirects-complete
                 :section-numbers nil
                 :with-toc nil))
#+end_src

=ross-www/publish= can be used in local development, and also will be
invoked for production builds.  Invoke with a universal argument to
force a rebuild and to build the legacy site.

#+begin_src emacs-lisp :tangle ../../../../gen/website/build.el :results silent
  (defun ross-www/publish ()
    "Publish the website."
    (interactive)
    (if current-prefix-arg
        (ross-www/legacy-publish))
    (dolist (project '("org/projects/www/index.org" "org/projects/wkd/index.org"))
      (let ((project-file-name (expand-file-name project ross-www/src-directory)))
        (with-temp-buffer
          (insert-file-contents project-file-name)
          (set-visited-file-name project-file-name t)n
          (org-babel-execute-buffer)
          (org-babel-tangle)
          (not-modified))))
    (org-publish "rossabaker.com" current-prefix-arg))
#+end_src

* Nix package

This site is built with Nix.

#+begin_src nix :tangle ../../../../gen/website/default.nix :eval never
  { src, emacsNativeComp, gnupg, hugo, stdenv }:
  let
    siteEmacs = emacsNativeComp.pkgs.withPackages (epkgs: [
      epkgs.htmlize
      epkgs.ox-hugo
    ]);
  in
  stdenv.mkDerivation rec {
    name = "rossabaker.com";
    inherit src;
    buildInputs = [
      siteEmacs
      gnupg
      hugo
    ];
    buildPhase = ''
      cd ..
      export PATH=${gnupg}/bin:${hugo}/bin:$PATH
      export HOME=$(pwd)
      ${siteEmacs}/bin/emacs -Q --batch \
        --script ${./build.el} \
        --eval "(setq org-babel-confirm-evaluate nil)" \
        --eval "(ross-www/legacy-publish)" \
        --eval "(ross-www/publish)"
    '';
    installPhase = ''
      mkdir $out
      cp -r tmp/public_html/. $out
    '';
  }
#+end_src

- The =siteEmacs= is a lightweight Emacs that contains just the
  packages we need to build the site.
- =hugo= and =ox-hugo= support the [[https://ox-hugo.scripter.co/][ox-hugo]] legacy.
- =gnupg= is made available to export the armored public key.
